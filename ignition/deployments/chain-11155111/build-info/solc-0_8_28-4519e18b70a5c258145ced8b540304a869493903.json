{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-4519e18b70a5c258145ced8b540304a869493903",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SubscriptionPlatform.sol": "project/contracts/SubscriptionPlatform.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SubscriptionPlatform.sol": {
        "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.28;\r\n\r\ncontract SubscriptionPlatform {\r\n\r\n\r\n    enum SubscriptionState { Paused, IsActive }\r\n\r\n    struct SubscribeService {\r\n        uint128 id;\r\n        uint128 durationInDays;\r\n        uint128 fee;        \r\n        address owner;\r\n        uint earnings;\r\n        SubscriptionState state;\r\n        string name;\r\n    }\r\n\r\n    struct Subscription{\r\n        uint endtime;\r\n        bool exists;\r\n    }\r\n\r\n\r\n    \r\n    address private subOwner;\r\n    uint128 public subCount;\r\n    uint public contractBalance;\r\n    bool private _locked;\r\n\r\n    mapping(uint128=> SubscribeService) public subService;\r\n    mapping(uint128 =>mapping(address=>Subscription)) public subscriptions;\r\n    mapping(address => uint) internal balances;\r\n    mapping(address => uint128[]) public currentSubscriptions;\r\n    mapping(address => uint128[]) public createdSubscriptions;\r\n    mapping(address => mapping(uint128 => bool)) private isSubscribed;\r\n\r\n    error NotSubscriptionOwner();\r\n\r\n    modifier onlySubscriptionOwner(uint128 subId){\r\n        if(subService[subId].owner != msg.sender){\r\n            revert NotSubscriptionOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier noReentrancy() {\r\n    require(!_locked, \"Stop making re-entracy calls. Please hold\");\r\n    _locked = true;\r\n    _;\r\n    _locked = false;\r\n    }\r\n\r\n    modifier hasSufficientBalance(uint withdrawalAmount) {\r\n    require(balances[msg.sender] >= withdrawalAmount, \"You have an insufficient balance\");\r\n    _;\r\n    }\r\n\r\n    receive() external payable {\r\n    balances[msg.sender] += msg.value;\r\n    contractBalance += msg.value;\r\n\r\n    assert(contractBalance == address(this).balance);\r\n\r\n    emit DepositMade(msg.sender, msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n    emit FallbackCalled(msg.sender);\r\n    revert(\"Fallback function called: invalid function.\");\r\n    }\r\n\r\n    constructor(address contractOwner) {\r\n        subOwner = contractOwner;\r\n    }\r\n\r\n    event SubscriptionCreated(uint indexed id, string name, address indexed owner);\r\n    event Subscribed (address indexed subscriber, uint indexed subscriptionId, uint endtime);\r\n    event SubscriptionGifted(address indexed from , address indexed to , uint indexed subscriptionId, uint endtime); \r\n    event WithdrawalMade(address indexed accountAddress, uint amount);\r\n    event DepositMade(address indexed sender, uint amount);\r\n    event FallbackCalled(address indexed sender);\r\n\r\n    function createSubscription(\r\n        string calldata name,\r\n        uint128 durationInDays,\r\n        uint128 fee\r\n    )\r\n        external\r\n    {\r\n        ++subCount;\r\n        uint128 id = subCount;\r\n\r\n        subService[id] = SubscribeService({\r\n            id: id,\r\n            name: name,\r\n            owner: msg.sender,\r\n            durationInDays: durationInDays,\r\n            fee: fee,\r\n            state: SubscriptionState.IsActive,\r\n            earnings: 0\r\n        });\r\n\r\n        createdSubscriptions[msg.sender].push(id);\r\n\r\n        \r\n        emit SubscriptionCreated(id,name,msg.sender);\r\n        \r\n    }\r\n\r\n    function getSubscriptions() external view returns (uint128[] memory, string[] memory) {\r\n        uint128[] memory ids = createdSubscriptions[msg.sender];\r\n        uint idLength = ids.length;\r\n\r\n        string[] memory names = new string[](idLength);\r\n\r\n        for (uint i = 0; i < idLength; i++) {\r\n            names[i] = subService[ids[i]].name;\r\n        }\r\n\r\n        return (ids, names);\r\n    }\r\n\r\n    function getCurrentSubscriptions() external view returns(uint128[] memory){\r\n        return currentSubscriptions[msg.sender]; \r\n    }\r\n\r\n    function changeFee(uint128 subId, uint128 newFee) external onlySubscriptionOwner(subId){\r\n        subService[subId].fee = newFee;\r\n    }\r\n\r\n    function pauseSubscription(uint128 subId) external onlySubscriptionOwner(subId){\r\n        subService[subId].state = SubscriptionState.Paused;\r\n    }\r\n\r\n    function resumeSucription(uint128 subId) external onlySubscriptionOwner(subId){\r\n        subService[subId].state = SubscriptionState.IsActive;\r\n    }\r\n\r\n    function hasActiveSubscription(uint128 subId, address user) external view returns(bool){\r\n        Subscription storage subscriber = subscriptions[subId][user];\r\n        return (subscriber.exists && subscriber.endtime > block.timestamp);\r\n    }\r\n\r\n\r\n\r\n    function subscribe(uint128 subscriptionId) external payable noReentrancy{\r\n        SubscribeService storage service = subService[subscriptionId];\r\n        require(service.state == SubscriptionState.IsActive, \"Subscription is paused.\");\r\n        require(msg.value>= service.fee, \"Insuffient payment.\");\r\n\r\n        Subscription storage customerSub = subscriptions[subscriptionId][msg.sender];\r\n\r\n        require(!customerSub.exists || block.timestamp >= customerSub.endtime, \"Subscription is still active.\");\r\n        require(msg.value == service.fee, \"Please send in the correct fee for this subscription.\");\r\n\r\n        uint newEndtime = block.timestamp + (service.durationInDays * 1 days);\r\n        subscriptions[subscriptionId][msg.sender] = Subscription({\r\n            endtime:newEndtime,\r\n            exists: true\r\n\r\n        });\r\n         service.earnings += msg.value;\r\n         balances[service.owner] += msg.value;\r\n         contractBalance += msg.value;\r\n\r\n     if (!isSubscribed[msg.sender][subscriptionId]) {\r\n        currentSubscriptions[msg.sender].push(subscriptionId);\r\n        isSubscribed[msg.sender][subscriptionId] = true;\r\n    }\r\n    emit Subscribed ( msg.sender, subscriptionId, newEndtime);\r\n\r\n    assert(subscriptions[subscriptionId][msg.sender].endtime == newEndtime);\r\n\r\n\r\n    }\r\n\r\n    function giftSubscription(uint128 subscriptionId, address recipient)external payable noReentrancy{\r\n        require( recipient != msg.sender, \"You cannot gift yourself a subscription.\");\r\n\r\n        SubscribeService storage service = subService[subscriptionId];\r\n        require(service.state == SubscriptionState.IsActive, \"Subscription is paused.\");\r\n        require(msg.value == service.fee, \"incorrect fee.\");\r\n\r\n        Subscription storage subs = subscriptions[subscriptionId][recipient];\r\n\r\n        if( subs.exists && block.timestamp < subs.endtime){\r\n            subs.endtime += service.durationInDays * 1 days;\r\n        }else{\r\n            subs.endtime = block.timestamp + (service.durationInDays * 1 days);\r\n            subs.exists = true;\r\n        }\r\n\r\n        service.earnings += msg.value;\r\n        balances[service.owner] += msg.value;\r\n        contractBalance += msg.value;\r\n\r\n         if (!isSubscribed[msg.sender][subscriptionId]) {\r\n        currentSubscriptions[msg.sender].push(subscriptionId);\r\n        isSubscribed[msg.sender][subscriptionId] = true;\r\n    }       \r\n\r\n        emit SubscriptionGifted(msg.sender, recipient, subscriptionId, subs.endtime);\r\n\r\n    }\r\n\r\n    function withdrawEarnings(uint128 subId , uint amount)external noReentrancy onlySubscriptionOwner(subId) hasSufficientBalance(amount) {\r\n    require(amount <= 1 ether, \"You cannot withdraw more than 1 ETH per transaction\");\r\n\r\n\r\n    balances[msg.sender] -= amount;\r\n    contractBalance -= amount;\r\n\r\n    payable(msg.sender).transfer(amount);\r\n\r\n    assert(contractBalance == address(this).balance);\r\n\r\n    emit WithdrawalMade(msg.sender, amount);\r\n    }\r\n\r\n    function deposit() public payable {\r\n    balances[msg.sender] += msg.value;\r\n    contractBalance += msg.value;\r\n\r\n    assert(contractBalance == address(this).balance);\r\n\r\n    emit DepositMade(msg.sender, msg.value);\r\n   }\r\n\r\n}"
      }
    }
  }
}